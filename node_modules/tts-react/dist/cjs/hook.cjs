"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTts = void 0;
var _react = _interopRequireWildcard(require("react"));
var _controller = require("./controller.cjs");
var _utils = require("./utils.cjs");
var _highlighter = require("./highlighter.cjs");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Event handler for a TTS event:
 * - `onStart`
 * - `onPause`
 * - `onEnd`
 *
 * If not using `fetchAudioData` then the event will be `SpeechSynthesisEvent`.
 * Otherwise, the event will be the generic `Event` type used by `HTMLAudioElement`.
 */

/**
 * Event handler for a TTS error event.
 * `tts-react` wraps both `SpeechSynthesis` and `HTMLAudioElement` API's
 * which return the error information in diferrent ways. `tts-react` will
 * return the error message from to the handler if one is found.
 */

/**
 * Event handler if an attribute of speaking has changed:
 * - volume
 * - rate
 * - pitch
 */

/**
 * Event handler for TTS boundary events.
 *
 * If yousing `fetchAudioData` these events correspond to `timeupdate` events
 * for `HTMLAudioElement` where a `PollySpeechMark` could be found for the event's `currentTime`.
 *
 * Otherwise, these correspond to `boundary` events for `SpeechSynthesisUtterance`.
 */

const parseChildrenRecursively = _ref => {
  let {
    children,
    buffer,
    boundary,
    markColor,
    markBackgroundColor,
    markTextAsSpoken
  } = _ref;
  return _react.Children.map(children, child => {
    let currentChild = child;
    if ( /*#__PURE__*/(0, _react.isValidElement)(child)) {
      currentChild = /*#__PURE__*/(0, _react.cloneElement)(child, {
        ...child.props,
        children: parseChildrenRecursively({
          buffer,
          boundary,
          markColor,
          markBackgroundColor,
          markTextAsSpoken,
          children: child.props.children
        })
      });
    }
    if ((0, _utils.isStringOrNumber)(child)) {
      const text = child.toString();
      const {
        word,
        startChar,
        endChar
      } = boundary;
      const bufferTextLength = buffer.text.length;
      buffer.text += `${text} `;
      if (markTextAsSpoken && word) {
        const start = startChar - bufferTextLength;
        const end = endChar - bufferTextLength;
        const prev = text.substring(0, start);
        const found = text.substring(start, end);
        const after = text.substring(end, text.length);
        if (found) {
          return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
            children: [prev, /*#__PURE__*/(0, _jsxRuntime.jsx)(_highlighter.Highlighter, {
              text: found,
              mark: (0, _utils.stripPunctuation)(found),
              color: markColor,
              backgroundColor: markBackgroundColor
            }), after]
          });
        }
      }
    }
    return currentChild;
  });
};
const defaultBoundary = {
  word: '',
  startChar: 0,
  endChar: 0
};
const reducer = (state, action) => {
  switch (action.type) {
    case 'pause':
      return {
        ...state,
        isPlaying: false,
        isPaused: true,
        isError: false
      };
    case 'play':
    case 'reset':
      return {
        ...state,
        isPlaying: true,
        isPaused: false,
        isError: false,
        boundary: defaultBoundary
      };
    case 'end':
      return {
        ...state,
        isPlaying: false,
        isPaused: false,
        isError: false,
        boundary: defaultBoundary
      };
    case 'error':
      return {
        ...state,
        isPlaying: false,
        isPaused: false,
        isError: true,
        boundary: defaultBoundary
      };
    case 'ready':
      return {
        ...state,
        isReady: true
      };
    case 'boundary':
      return {
        ...state,
        boundary: {
          ...state.boundary,
          ...action.payload
        }
      };
    case 'voices':
      return {
        ...state,
        voices: action.payload
      };
    case 'stop':
      return {
        ...state,
        isPlaying: false,
        isPaused: false,
        isError: false
      };
    case 'muted':
      return {
        ...state,
        isMuted: true
      };
    case 'unmuted':
      return {
        ...state,
        isMuted: false
      };
  }
};
const useTts = _ref2 => {
  let {
    lang,
    rate,
    volume,
    voice,
    children,
    markColor,
    markBackgroundColor,
    onStart,
    onPause,
    onBoundary,
    onEnd,
    onError,
    onVolumeChange,
    onPitchChange,
    onRateChange,
    fetchAudioData,
    autoPlay = false,
    markTextAsSpoken = false
  } = _ref2;
  const spokenTextRef = (0, _react.useRef)();
  const [state, dispatch] = (0, _react.useReducer)(reducer, {
    voices: window.speechSynthesis?.getVoices() ?? [],
    boundary: defaultBoundary,
    isPlaying: false,
    isPaused: false,
    isMuted: false,
    isError: false,
    isReady: typeof fetchAudioData === 'undefined'
  });
  const [ttsChildren, spokenText] = (0, _react.useMemo)(() => {
    if (typeof spokenTextRef.current === 'undefined' || markTextAsSpoken) {
      const buffer = {
        text: ''
      };
      const parsed = parseChildrenRecursively({
        children,
        buffer,
        markColor,
        markBackgroundColor,
        markTextAsSpoken,
        boundary: state.boundary
      });
      spokenTextRef.current = buffer.text.trim();
      return [parsed, spokenTextRef.current];
    }
    return [children, spokenTextRef.current];
  }, [children, state.boundary, markColor, markBackgroundColor, markTextAsSpoken]);
  const controller = (0, _react.useMemo)(() => new _controller.Controller({
    lang,
    voice,
    fetchAudioData
  }), [lang, voice, fetchAudioData]);
  const play = (0, _react.useCallback)(async () => {
    if (state.isPaused) {
      controller.resume();
    } else {
      // Replay gives a more consistent/expected experience
      controller.replay();
    }
    dispatch({
      type: 'play'
    });
  }, [controller, state.isPaused]);
  const pause = (0, _react.useCallback)(() => {
    controller.pause();
    dispatch({
      type: 'pause'
    });
  }, [controller]);
  const replay = (0, _react.useCallback)(() => {
    controller.replay();
    dispatch({
      type: 'reset'
    });
  }, [controller]);
  const stop = (0, _react.useCallback)(() => {
    controller.cancel();
    dispatch({
      type: 'stop'
    });
  }, [controller]);
  const toggleMuteHandler = (0, _react.useCallback)(callback => {
    const wasMuted = parseFloat(controller.volume.toFixed(2)) === controller.volumeMin;
    if (wasMuted) {
      controller.unmute();
      dispatch({
        type: 'unmuted'
      });
    } else {
      controller.mute();
      dispatch({
        type: 'muted'
      });
    }
    if (typeof callback === 'function') {
      callback(wasMuted);
    }
  }, [controller]);
  const playOrPause = (0, _react.useMemo)(() => state.isPlaying ? pause : play, [state.isPlaying, pause, play]);
  const playOrStop = (0, _react.useMemo)(() => state.isPlaying ? stop : play, [state.isPlaying, stop, play]);
  const [get, set] = (0, _react.useMemo)(() => [{
    lang() {
      return controller.lang;
    },
    rate() {
      return controller.rate;
    },
    pitch() {
      return controller.pitch;
    },
    volume() {
      return controller.volume;
    },
    preservesPitch() {
      return controller.preservesPitch;
    }
  }, {
    lang(value) {
      controller.lang = value;
    },
    rate(value) {
      controller.rate = value;
    },
    pitch(value) {
      controller.pitch = value;
    },
    volume(value) {
      controller.volume = value;
    },
    preservesPitch(value) {
      controller.preservesPitch = value;
    }
  }], [controller]);
  // Controller event listeners
  const onStartHandler = (0, _react.useCallback)(evt => {
    dispatch({
      type: 'play'
    });
    if (typeof onStart === 'function') {
      onStart(evt.detail);
    }
  }, [onStart]);
  const onPauseHandler = (0, _react.useCallback)(evt => {
    if (typeof onPause === 'function') {
      onPause(evt.detail);
    }
  }, [onPause]);
  const onEndHandler = (0, _react.useCallback)(evt => {
    dispatch({
      type: 'end'
    });
    if (typeof onEnd === 'function') {
      onEnd(evt.detail);
    }
  }, [onEnd]);
  const onReady = (0, _react.useCallback)(() => {
    dispatch({
      type: 'ready'
    });
  }, []);
  const onErrorHandler = (0, _react.useCallback)(evt => {
    dispatch({
      type: 'error'
    });
    if (typeof onError === 'function') {
      onError(evt.detail);
    }
  }, [onError]);
  const onBoundaryHandler = (0, _react.useCallback)(evt => {
    dispatch({
      type: 'boundary',
      payload: evt.detail.boundary
    });
    if (typeof onBoundary === 'function') {
      onBoundary(evt.detail.boundary, evt.detail.evt);
    }
  }, [onBoundary]);
  const onVolume = (0, _react.useCallback)(evt => {
    const volume = evt.detail;
    const min = controller.volumeMin;
    if (volume === min && controller.volume !== min) {
      dispatch({
        type: 'muted'
      });
    }
    if (volume !== min && controller.volume === min) {
      dispatch({
        type: 'unmuted'
      });
    }
    if (typeof onVolumeChange === 'function') {
      onVolumeChange(volume);
    }
  }, [onVolumeChange, controller]);
  const onPitch = (0, _react.useCallback)(evt => {
    if (typeof onPitchChange === 'function') {
      onPitchChange(evt.detail);
    }
  }, [onPitchChange]);
  const onRate = (0, _react.useCallback)(evt => {
    if (typeof onRateChange === 'function') {
      onRateChange(evt.detail);
    }
  }, [onRateChange]);
  (0, _react.useEffect)(() => {
    controller.text = spokenText;
  }, [spokenText, controller]);
  (0, _react.useEffect)(() => {
    if (rate && Number.isFinite(rate)) {
      controller.rate = rate;
    }
    if (volume && Number.isFinite(volume)) {
      controller.volume = volume;
    }
  }, [controller, rate, volume]);
  (0, _react.useEffect)(() => {
    const onBeforeUnload = () => {
      controller.cancel();
    };
    const initializeListeners = async () => {
      controller.addEventListener(_controller.Events.PLAYING, onStartHandler);
      controller.addEventListener(_controller.Events.PAUSED, onPauseHandler);
      controller.addEventListener(_controller.Events.END, onEndHandler);
      controller.addEventListener(_controller.Events.ERROR, onErrorHandler);
      controller.addEventListener(_controller.Events.READY, onReady);
      controller.addEventListener(_controller.Events.BOUNDARY, onBoundaryHandler);
      controller.addEventListener(_controller.Events.VOLUME, onVolume);
      controller.addEventListener(_controller.Events.PITCH, onPitch);
      controller.addEventListener(_controller.Events.RATE, onRate);
      window.addEventListener('beforeunload', onBeforeUnload);
      await controller.init();
    };
    initializeListeners();
    return () => {
      window.removeEventListener('beforeunload', onBeforeUnload);
      controller.removeEventListener(_controller.Events.PLAYING, onStartHandler);
      controller.removeEventListener(_controller.Events.PAUSED, onPauseHandler);
      controller.removeEventListener(_controller.Events.END, onEndHandler);
      controller.removeEventListener(_controller.Events.ERROR, onErrorHandler);
      controller.removeEventListener(_controller.Events.READY, onReady);
      controller.removeEventListener(_controller.Events.BOUNDARY, onBoundaryHandler);
      controller.removeEventListener(_controller.Events.VOLUME, onVolume);
      controller.removeEventListener(_controller.Events.PITCH, onPitch);
      controller.removeEventListener(_controller.Events.RATE, onRate);
    };
  }, [onStartHandler, onBoundaryHandler, onPauseHandler, onEndHandler, onReady, onErrorHandler, onBoundary, onVolume, onPitch, onRate, controller]);
  (0, _react.useEffect)(() => {
    if (autoPlay && state.isReady) {
      controller.replay();
      dispatch({
        type: 'play'
      });
    }
  }, [autoPlay, controller, state.isReady, spokenText]);
  (0, _react.useEffect)(() => {
    const onVoicesChanged = () => {
      dispatch({
        type: 'voices',
        payload: window.speechSynthesis.getVoices()
      });
    };
    if (typeof window.speechSynthesis?.addEventListener === 'function') {
      window.speechSynthesis.addEventListener('voiceschanged', onVoicesChanged);
    }
    return () => {
      if (typeof window.speechSynthesis?.removeEventListener === 'function') {
        window.speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged);
      }
    };
  }, []);
  return {
    get,
    set,
    state,
    spokenText,
    ttsChildren,
    play,
    stop,
    pause,
    replay,
    playOrStop,
    playOrPause,
    toggleMute: toggleMuteHandler
  };
};
exports.useTts = useTts;