"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padding = exports.Control = void 0;
var _react = _interopRequireWildcard(require("react"));
var _icons = require("./icons.cjs");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const padding = exports.padding = {
  [_icons.Sizes.SMALL]: 5,
  [_icons.Sizes.MEDIUM]: 5,
  [_icons.Sizes.LARGE]: 5
};
const button = _ref => {
  let {
    size,
    align,
    type
  } = _ref;
  const styles = {
    margin: 0,
    padding: `${padding[size]}px`,
    border: 'none',
    borderRadius: `${_icons.iconSizes[size]}px`,
    color: 'black',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'transparent'
  };
  if (type === 'replay') {
    // Include left/right padding + gutter
    const value = `-${_icons.iconSizes[size] + 2 * padding[size] + 5}px`;
    const property = align === 'horizontal' ? 'right' : 'bottom';
    return {
      ...styles,
      [property]: value,
      position: 'absolute',
      background: '#f2f1f1a6',
      zIndex: 9999
    };
  }
  return styles;
};
const Control = _ref2 => {
  let {
    title,
    type,
    onClick,
    size = _icons.Sizes.MEDIUM,
    align = 'horizontal',
    ...rest
  } = _ref2;
  const styleDataId = 'tts-react-controls';
  const svg = (0, _react.useMemo)(() => {
    return _icons.icons[type](size);
  }, [type, size]);
  const btnStyle = (0, _react.useMemo)(() => button({
    size,
    align,
    type
  }), [size, align, type]);
  (0, _react.useEffect)(() => {
    // Keep pseudo styles in stylesheets where they are supported.
    let style = document.querySelector(`style[data-id="${styleDataId}"]`);
    if (!style) {
      style = document.createElement('style');
      style.setAttribute('data-id', styleDataId);
      style.innerHTML = `
        button[data-tts-react-control]:hover {
          background-color: #ebeaeaa6 !important;
        }
        button[data-id="tts-react-replay"]:hover {
          filter: brightness(0.98);
        }
      `;
      document.head.appendChild(style);
    }
    return () => {
      // Cleanup reference to DOM element
      style = null;
    };
  }, [align, size, type]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
    title: title,
    "data-tts-react-control": true,
    "data-id": `tts-react-${type}`,
    onClick: onClick,
    style: btnStyle,
    dangerouslySetInnerHTML: {
      __html: svg
    },
    ...rest
  });
};
exports.Control = Control;