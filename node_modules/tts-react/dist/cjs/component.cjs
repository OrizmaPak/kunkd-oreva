"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Positions = void 0;
Object.defineProperty(exports, "Sizes", {
  enumerable: true,
  get: function () {
    return _icons.Sizes;
  }
});
exports.TextToSpeech = void 0;
var _react = _interopRequireWildcard(require("react"));
var _hook = require("./hook.cjs");
var _icons = require("./icons.cjs");
var _control = require("./control.cjs");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// No umd build for react/jsx-runtime @see https://github.com/facebook/react/issues/20923
var Positions = exports.Positions = /*#__PURE__*/function (Positions) {
  Positions["TL"] = "topLeft";
  Positions["TR"] = "topRight";
  Positions["BL"] = "bottomLeft";
  Positions["BR"] = "bottomRight";
  Positions["TC"] = "topCenter";
  Positions["RC"] = "rightCenter";
  Positions["BC"] = "bottomCenter";
  Positions["LC"] = "leftCenter";
  return Positions;
}(Positions || {});
const wrap = _ref => {
  let {
    position = Positions.LC
  } = _ref;
  let gridTemplateAreas = `'cnt ctl'`;
  let gridTemplateColumns = '1fr auto';
  let alignItems = 'start';
  switch (position) {
    case Positions.TL:
      gridTemplateAreas = `'ctl cnt'`;
      gridTemplateColumns = 'auto 1fr';
      break;
    case Positions.BL:
      gridTemplateAreas = `'ctl cnt'`;
      alignItems = 'end';
      gridTemplateColumns = 'auto 1fr';
      break;
    case Positions.BR:
      gridTemplateAreas = `'cnt ctl'`;
      alignItems = 'end';
      break;
    case Positions.TC:
      gridTemplateColumns = '1fr';
      gridTemplateAreas = `'ctl'\n'cnt'`;
      alignItems = 'center';
      break;
    case Positions.RC:
      alignItems = 'center';
      break;
    case Positions.BC:
      gridTemplateColumns = '1fr';
      gridTemplateAreas = `'cnt'\n'ctl'`;
      alignItems = 'center';
      break;
    case Positions.LC:
      gridTemplateAreas = `'ctl cnt'`;
      gridTemplateColumns = 'auto 1fr';
      alignItems = 'center';
  }
  return {
    alignItems,
    gridTemplateAreas,
    gridTemplateColumns,
    display: 'grid',
    gap: '15px'
  };
};
const controls = _ref2 => {
  let {
    align,
    position = Positions.LC,
    size = _icons.Sizes.MEDIUM
  } = _ref2;
  return {
    position: 'relative',
    display: 'inline-flex',
    flexDirection: align === 'horizontal' ? 'row' : 'column',
    gap: '5px',
    gridArea: 'ctl',
    padding: 0,
    margin: position.includes('Center') ? 'auto' : 0,
    backgroundColor: '#f2f1f1a6',
    borderRadius: `${_icons.iconSizes[size] + _control.padding[size]}px`,
    border: '1px solid transparent'
  };
};
const content = () => {
  return {
    gridArea: 'cnt'
  };
};
/**
 * `useTts` is a React hook for converting text to speech using
 * the `SpeechSynthesis` and `SpeechSynthesisUtterance` Browser API's.
 * Optionally, you can fallback to using the `HTMLAudioElement` API
 * when setting the `fetchAudioData` prop, for example to use Amazon Polly,
 * or MS Azure Cognitive Speech Services.
 *
 * The `TextToSpeech` component is an implementation of `useTts` that provides
 * controls for playing, pausing/stopping, and replaying the spoken text.
 * It also extends the props of `useTts` by supporting some of it's own:
 *
 * - `align`
 * - `allowMuting`
 * - `onMuteToggled`
 * - `position`
 * - `size`
 * - `useStopOverPause`
 */
const TextToSpeech = _ref3 => {
  let {
    size,
    lang,
    rate,
    voice,
    volume,
    children,
    position,
    onStart,
    onPause,
    onBoundary,
    onEnd,
    onError,
    onMuteToggled,
    onVolumeChange,
    onPitchChange,
    onRateChange,
    fetchAudioData,
    markColor,
    markBackgroundColor,
    autoPlay = false,
    allowMuting = true,
    align = 'horizontal',
    markTextAsSpoken = false,
    useStopOverPause = false
  } = _ref3;
  const {
    state,
    replay,
    toggleMute,
    playOrPause,
    playOrStop,
    ttsChildren
  } = (0, _hook.useTts)({
    lang,
    rate,
    voice,
    volume,
    children,
    onStart,
    onPause,
    onBoundary,
    onEnd,
    onError,
    onVolumeChange,
    onPitchChange,
    onRateChange,
    fetchAudioData,
    autoPlay,
    markColor,
    markBackgroundColor,
    markTextAsSpoken
  });
  const wrapStyle = (0, _react.useMemo)(() => wrap({
    position
  }), [position]);
  const controlsStyle = (0, _react.useMemo)(() => controls({
    align,
    position,
    size
  }), [align, position, size]);
  const contentStyle = (0, _react.useMemo)(() => content(), []);
  const [type, title, onClick] = (0, _react.useMemo)(() => {
    if (state.isPlaying) {
      if (useStopOverPause) {
        return ['stop', 'Stop', playOrStop];
      }
      return ['pause', 'Pause', playOrPause];
    }
    return ['play', 'Play', playOrPause];
  }, [state.isPlaying, useStopOverPause, playOrStop, playOrPause]);
  const handleOnMuteClicked = (0, _react.useCallback)(() => {
    toggleMute(onMuteToggled);
  }, [toggleMute, onMuteToggled]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    style: wrapStyle,
    className: "tts-react",
    children: [state.isReady && /*#__PURE__*/(0, _jsxRuntime.jsxs)("aside", {
      style: controlsStyle,
      children: [allowMuting && /*#__PURE__*/(0, _jsxRuntime.jsx)(_control.Control, {
        size: size,
        align: align,
        title: state.isMuted ? 'Unmute' : 'Mute',
        "aria-label": state.isMuted ? 'Unmute' : 'Mute',
        onClick: handleOnMuteClicked,
        type: state.isMuted ? 'volumeOff' : state.isPlaying ? 'volumeUp' : 'volumeDown'
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_control.Control, {
        type: type,
        title: title,
        "aria-label": title,
        onClick: onClick,
        size: size,
        align: align
      }), state.isPaused && /*#__PURE__*/(0, _jsxRuntime.jsx)(_control.Control, {
        type: "replay",
        size: size,
        align: align,
        title: "Replay",
        "aria-label": "Replay",
        onClick: replay
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      style: contentStyle,
      children: ttsChildren
    })]
  });
};
exports.TextToSpeech = TextToSpeech;